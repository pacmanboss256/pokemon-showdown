"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stats = exports.Learnsets = exports.Type = exports.Types = exports.Natures = exports.Effects = exports.Specie = exports.Species = exports.Moves = exports.Items = exports.Abilities = exports.Generation = exports.Generations = exports.toID = void 0;
const DEFAULT_EXISTS = (d) => {
    if (!d.exists)
        return false;
    if ('isNonstandard' in d && d.isNonstandard)
        return false;
    if (d.kind === 'Ability' && d.id === 'noability')
        return false;
    return !('tier' in d && ['Illegal', 'Unreleased'].includes(d.tier));
};
const tr = (num, bits = 0) => bits ? (num >>> 0) % (2 ** bits) : num >>> 0;
function assignWithout(a, b, exclude) {
    for (const key in b) {
        if (Object.prototype.hasOwnProperty.call(b, key) && !exclude.has(key)) {
            a[key] = b[key];
        }
    }
    return a;
}
function toID(text) {
    if (text === null || text === void 0 ? void 0 : text.id)
        text = text.id;
    if (typeof text !== 'string' && typeof text !== 'number')
        return '';
    return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '');
}
exports.toID = toID;
class Generations {
    constructor(dex, exists = DEFAULT_EXISTS) {
        this.cache = Object.create(null);
        this.dex = dex;
        this.exists = exists;
    }
    get(gen) {
        if (this.cache[gen])
            return this.cache[gen];
        return (this.cache[gen] = new Generation(this.dex.forGen(gen), this.exists));
    }
    *[Symbol.iterator]() {
        for (let gen = 1; gen <= 8; gen++) {
            yield this.get(gen);
        }
    }
}
exports.Generations = Generations;
class Generation {
    constructor(dex, exists) {
        this.dex = dex;
        this.exists = exists;
        this.abilities = new Abilities(this.dex, this.exists);
        this.items = new Items(this.dex, this.exists);
        this.moves = new Moves(this.dex, this.exists);
        this.species = new Species(this.dex, this.exists);
        this.natures = new Natures(this.dex, this.exists);
        this.types = new Types(this.dex, this.exists);
        this.learnsets = new Learnsets(this, this.dex, this.exists);
        this.effects = new Effects(this.dex, this.exists);
        this.stats = new Stats(this.dex);
    }
    get num() {
        return this.dex.gen;
    }
    toString() {
        return `[Generation:${this.num}]`;
    }
    toJSON() {
        return this.toString();
    }
}
exports.Generation = Generation;
class Abilities {
    constructor(dex, exists) {
        this.dex = dex;
        this.exists = exists;
    }
    get(name) {
        const ability = this.dex.getAbility(name);
        return this.exists(ability) ? ability : undefined;
    }
    *[Symbol.iterator]() {
        for (const ability in this.dex.data.Abilities) {
            const a = this.get(ability);
            if (a)
                yield a;
        }
    }
}
exports.Abilities = Abilities;
class Items {
    constructor(dex, exists) {
        this.dex = dex;
        this.exists = exists;
    }
    get(name) {
        const item = this.dex.getItem(name);
        return this.exists(item) ? item : undefined;
    }
    *[Symbol.iterator]() {
        for (const item in this.dex.data.Items) {
            const i = this.get(item);
            if (i)
                yield i;
        }
    }
}
exports.Items = Items;
class Moves {
    constructor(dex, exists) {
        this.dex = dex;
        this.exists = exists;
    }
    get(name) {
        const move = this.dex.getMove(name);
        return this.exists(move) ? move : undefined;
    }
    *[Symbol.iterator]() {
        for (const move in this.dex.data.Moves) {
            const m = this.get(move);
            if (m)
                yield m;
        }
    }
}
exports.Moves = Moves;
class Species {
    constructor(dex, exists) {
        this.cache = Object.create(null);
        this.dex = dex;
        this.exists = exists;
    }
    get(name) {
        const species = this.dex.getSpecies(name);
        if (!this.exists(species))
            return undefined;
        const id = species.speciesid || species.id; // FIXME Event-only ability hack
        const cached = this.cache[id];
        if (cached)
            return cached;
        return (this.cache[id] = new Specie(this.dex, this.exists, species));
    }
    *[Symbol.iterator]() {
        for (const species in this.dex.data.Species) {
            const s = this.get(species);
            if (s)
                yield s;
        }
    }
}
exports.Species = Species;
class Specie {
    constructor(dex, exists, species) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        assignWithout(this, species, Specie.EXCLUDE);
        this.dex = dex;
        if (this.dex.gen >= 2) {
            this.gender = species.gender;
            this.genderRatio = species.genderRatio;
        }
        else {
            this.genderRatio = { M: 0, F: 0 };
        }
        this.evos = (_a = species.evos) === null || _a === void 0 ? void 0 : _a.filter(s => exists(this.dex.getSpecies(s)));
        this.nfe = !!((_b = this.evos) === null || _b === void 0 ? void 0 : _b.length);
        if (!this.nfe)
            this.evos = undefined;
        this.cosmeticFormes = (_c = species.cosmeticFormes) === null || _c === void 0 ? void 0 : _c.filter(s => exists(this.dex.getSpecies(s)));
        if (!((_d = this.cosmeticFormes) === null || _d === void 0 ? void 0 : _d.length))
            this.cosmeticFormes = undefined;
        this.otherFormes = (_e = species.otherFormes) === null || _e === void 0 ? void 0 : _e.filter(s => exists(this.dex.getSpecies(s)));
        if (!((_f = this.otherFormes) === null || _f === void 0 ? void 0 : _f.length))
            this.otherFormes = undefined;
        this.formeOrder = (_g = species.formeOrder) === null || _g === void 0 ? void 0 : _g.filter(s => exists(this.dex.getSpecies(s)));
        if (!((_h = this.formeOrder) === null || _h === void 0 ? void 0 : _h.length))
            this.formeOrder = undefined;
        this.formes = (_j = this.formeOrder) === null || _j === void 0 ? void 0 : _j.filter(s => !this.dex.getSpecies(s).isGigantamax);
        this.prevo =
            species.prevo && exists(this.dex.getSpecies(species.prevo)) ? species.prevo : undefined;
    }
    hasAbility(ability) {
        return this.dex.hasAbility(this, ability);
    }
    get formeNum() {
        return (this.baseSpecies === this.name
            ? this.formeOrder ? this.formeOrder.findIndex(name => name === this.name) : 0
            : this.dex.getSpecies(this.baseSpecies).formeOrder.findIndex(name => name === (this.isGigantamax ? this.baseSpecies : this.name)));
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return assignWithout({}, this, new Set(['dex']));
    }
}
exports.Specie = Specie;
Specie.EXCLUDE = new Set([
    'evos',
    'gender',
    'genderRatio',
    'cosmeticFormes',
    'nfe',
    'otherFormes',
    'prevo',
]);
class Effects {
    constructor(dex, exists) {
        this.dex = dex;
        this.exists = exists;
    }
    get(name) {
        const effect = this.dex.getEffect(name);
        return this.exists(effect) ? effect : undefined;
    }
}
exports.Effects = Effects;
class Natures {
    constructor(dex, exists) {
        this.dex = dex;
        this.exists = exists;
    }
    get(name) {
        if (this.dex.gen < 3)
            return undefined;
        const nature = this.dex.getNature(name);
        return this.exists(nature) ? nature : undefined;
    }
    *[Symbol.iterator]() {
        for (const nature in this.dex.data.Natures) {
            const n = this.get(nature);
            if (n)
                yield n;
        }
    }
}
exports.Natures = Natures;
const EFFECTIVENESS = {
    '-2': 0.25,
    '-1': 0.5,
    '0': 1,
    '1': 2,
    '2': 4,
};
class Types {
    constructor(dex, exists) {
        this.cache = Object.create(null);
        this.dex = dex;
        this.exists = exists;
        // PS doesn't contain data for the '???' type
        this.unknown = new Type({
            effectType: 'Type',
            kind: 'Type',
            // Regrettably PS ID's can't represent '???'
            id: '',
            name: '???',
            // Technically this only exists as a true type in Gens 2-4, but there are moves dealing
            // typeless damage in Gen 1 so we include it there.
            exists: dex.gen <= 4,
            gen: 1,
            // This gets filled in for us by Type's constructor
            damageTaken: {},
            HPivs: {},
            HPdvs: {},
        }, dex, this);
    }
    get(name) {
        if (name === '???')
            return this.unknown;
        const type = this.dex.getType(name);
        if (!this.exists(type))
            return undefined;
        const cached = this.cache[type.id];
        if (cached)
            return cached;
        return (this.cache[type.id] = new Type(type, this.dex, this));
    }
    *[Symbol.iterator]() {
        for (const type in this.dex.data.Types) {
            yield this.get(type);
        }
        if (this.dex.gen >= 2 && this.dex.gen <= 4) {
            yield this.unknown;
        }
    }
    getHiddenPower(ivs) {
        return this.dex.getHiddenPower(ivs);
    }
    canDamage(source, target) {
        return this.dex.getImmunity(source, target);
    }
    totalEffectiveness(source, target) {
        const e = `${this.dex.getEffectiveness(source, target)}`;
        // convert from PS's ridiculous encoding to something usable
        return EFFECTIVENESS[e];
    }
}
exports.Types = Types;
const DAMAGE_TAKEN = [1, 2, 0.5, 0];
const SPECIAL = ['Fire', 'Water', 'Grass', 'Electric', 'Ice', 'Psychic', 'Dark', 'Dragon'];
class Type {
    constructor(type, dex, types) {
        Object.assign(this, type);
        this.types = types;
        this.category =
            this.name === 'Fairy' ? undefined : SPECIAL.includes(this.name) ? 'Special' : 'Physical';
        // convert from PS's ridiculous encoding to something usable (plus damage taken -> dealt)
        this.effectiveness = { '???': 1 };
        for (const k in dex.data.Types) {
            const t = k;
            this.effectiveness[t] = DAMAGE_TAKEN[dex.data.Types[t].damageTaken[this.name] || 0];
        }
    }
    canDamage(target) {
        return this.types.canDamage(this.name, target);
    }
    totalEffectiveness(target) {
        return this.types.totalEffectiveness(this.name, target);
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return assignWithout({}, this, new Set(['types']));
    }
}
exports.Type = Type;
const GEN3_HMS = new Set(['cut', 'fly', 'surf', 'strength', 'flash', 'rocksmash', 'waterfall', 'dive']);
// NOTE: Whirlpool and Defog are Gen 4 HMs but the HMs differ in DPPt vs. HGSS
const GEN4_HMS = new Set(['cut', 'fly', 'surf', 'strength', 'rocksmash', 'waterfall', 'rockclimb']);
class Learnsets {
    constructor(gen, dex, exists) {
        this.cache = Object.create(null);
        this.gen = gen;
        this.dex = dex;
        this.exists = exists;
    }
    async get(name) {
        const learnset = await this.dex.getLearnset(toID(name));
        return this.exists(learnset) ? learnset : undefined;
    }
    [Symbol.iterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            if (!this.dex.data.Learnsets)
                yield __await(this.dex.getLearnset('LOAD'));
            for (const id in this.dex.data.Learnsets) {
                const l = yield __await(this.get(id));
                if (l)
                    yield yield __await(l);
            }
        });
    }
    all(species) {
        return __asyncGenerator(this, arguments, function* all_1() {
            let id = species.id;
            let learnset = yield __await(this.get(id));
            if (!learnset) {
                id = typeof species.battleOnly === 'string' && species.battleOnly !== species.baseSpecies
                    ? toID(species.battleOnly)
                    : toID(species.baseSpecies);
                learnset = yield __await(this.get(id));
            }
            while (learnset) {
                yield yield __await(learnset);
                if (id === 'lycanrocdusk' || (species.id === 'rockruff' && id === 'rockruff')) {
                    id = 'rockruffdusk';
                }
                else if (species.id === 'gastrodoneast') {
                    id = 'gastrodon';
                }
                else if (species.id === 'pumpkaboosuper') {
                    id = 'pumpkaboo';
                }
                else {
                    id = toID(species.battleOnly || species.changesFrom || species.prevo);
                }
                if (!id)
                    break;
                const s = this.gen.species.get(id);
                if (!s)
                    break;
                species = s;
                learnset = yield __await(this.get(id));
            }
        });
    }
    async learnable(name, restriction) {
        var e_1, _a;
        const species = this.gen.species.get(name);
        if (!species)
            return undefined;
        if (!restriction) {
            const cached = this.cache[species.id];
            if (cached)
                return cached;
        }
        const moves = {};
        try {
            for (var _b = __asyncValues(this.all(species)), _c; _c = await _b.next(), !_c.done;) {
                const learnset = _c.value;
                if (learnset.learnset) {
                    for (const moveid in learnset.learnset) {
                        const move = this.gen.moves.get(moveid);
                        if (move) {
                            const sources = learnset.learnset[moveid];
                            if (Learnsets.isLegal(move, sources, restriction || this.gen)) {
                                moves[move.id] = sources.filter(s => +s.charAt(0) <= this.gen.num);
                            }
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!restriction)
            this.cache[species.id] = moves;
        return moves;
    }
    async canLearn(name, move, restriction) {
        var e_2, _a;
        var _b;
        const species = this.gen.species.get(name);
        if (!species)
            return false;
        move = typeof move === 'string' && this.gen.moves.get(move) || move;
        if (typeof move === 'string')
            return false;
        try {
            for (var _c = __asyncValues(this.all(species)), _d; _d = await _c.next(), !_d.done;) {
                const learnset = _d.value;
                if (Learnsets.isLegal(move, (_b = learnset.learnset) === null || _b === void 0 ? void 0 : _b[move.id], restriction || this.gen)) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) await _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    }
    static isLegal(move, sources, gen) {
        if (!sources)
            return undefined;
        const gens = sources.map(x => Number(x[0]));
        const minGen = Math.min(...gens);
        const vcOnly = (minGen === 7 && sources.every(x => x[0] !== '7' || x === '7V') ||
            minGen === 8 && sources.every(x => x[0] !== '8' || x === '8V'));
        if (gen === 'Pentagon')
            return gens.includes(6);
        if (gen === 'Plus')
            return gens.includes(7) && !vcOnly;
        if (gen === 'Galar')
            return gens.includes(8) && !vcOnly;
        if (minGen <= 4 && (GEN3_HMS.has(move.id) || GEN4_HMS.has(move.id))) {
            let legalGens = '';
            let available = false;
            if (minGen === 3) {
                legalGens += '3';
                available = true;
            }
            if (available)
                available = !GEN3_HMS.has(move.id);
            if (available || gens.includes(4)) {
                legalGens += '4';
                available = true;
            }
            if (available)
                available = !GEN4_HMS.has(move.id);
            const minUpperGen = available ? 5 : Math.min(...gens.filter(g => g > 4));
            legalGens += '012345678'.slice(minUpperGen);
            return legalGens.includes(`${gen.num}`);
        }
        else {
            return '012345678'.slice(minGen).includes(`${gen.num}`);
        }
    }
}
exports.Learnsets = Learnsets;
const STATS = ['hp', 'atk', 'def', 'spe', 'spa', 'spd'];
const NAMES = {
    HP: 'hp', hp: 'hp',
    Attack: 'atk', Atk: 'atk', atk: 'atk',
    Defense: 'def', Def: 'def', def: 'def',
    'Special Attack': 'spa', SpA: 'spa', SAtk: 'spa', SpAtk: 'spa', spa: 'spa',
    Special: 'spa', spc: 'spa', Spc: 'spa',
    'Special Defense': 'spd', SpD: 'spd', SDef: 'spd', SpDef: 'spd', spd: 'spd',
    Speed: 'spe', Spe: 'spe', Spd: 'spe', spe: 'spe',
};
const DISPLAY = {
    hp: ['HP', 'HP'],
    atk: ['Atk', 'Attack'],
    def: ['Def', 'Defense'],
    spa: ['SpA', 'Special Attack'],
    spd: ['SpD', 'Special Defense'],
    spe: ['Spe', 'Speed'],
    spc: ['Spc', 'Special'],
};
class Stats {
    constructor(dex) {
        this.dex = dex;
    }
    calc(stat, base, iv = 31, ev, level = 100, nature) {
        if (ev === undefined)
            ev = this.dex.gen < 3 ? 252 : 0;
        if (this.dex.gen < 3) {
            iv = this.toDV(iv) * 2;
            nature = undefined;
        }
        if (stat === 'hp') {
            return base === 1 ? base : tr(tr(2 * base + iv + tr(ev / 4) + 100) * level / 100 + 10);
        }
        else {
            const val = tr(tr(2 * base + iv + tr(ev / 4)) * level / 100 + 5);
            if (nature !== undefined) {
                if (nature.plus === stat)
                    return tr(tr(val * 110, 16) / 100);
                if (nature.minus === stat)
                    return tr(tr(val * 90, 16) / 100);
            }
            return val;
        }
    }
    get(s) {
        return NAMES[s];
    }
    display(str, full = false) {
        let s = NAMES[str];
        if (s === undefined)
            return str;
        if (this.dex.gen === 1 && s === 'spa')
            s = 'spc';
        return DISPLAY[s][+full];
    }
    fill(stats, val) {
        for (const stat of STATS) {
            if (!(stat in stats))
                stats[stat] = val;
        }
        return stats;
    }
    getHPDV(ivs) {
        return ((this.toDV(ivs.atk === undefined ? 31 : ivs.atk) % 2) * 8 +
            (this.toDV(ivs.def === undefined ? 31 : ivs.def) % 2) * 4 +
            (this.toDV(ivs.spe === undefined ? 31 : ivs.spe) % 2) * 2 +
            (this.toDV(ivs.spa === undefined ? 31 : ivs.spa) % 2));
    }
    *[Symbol.iterator]() {
        for (const s of STATS) {
            yield s;
        }
    }
    toDV(iv) {
        return Math.floor(iv / 2);
    }
    toIV(dv) {
        return dv * 2 + 1;
    }
}
exports.Stats = Stats;
//# sourceMappingURL=index.js.map