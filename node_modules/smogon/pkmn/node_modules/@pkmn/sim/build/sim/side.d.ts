import { ActiveMove, AnyObject, Battle, Condition, Effect, ID, Move, PokemonSet, SideID } from './exported-global-types';
import type { RequestState } from './battle';
import { Pokemon, EffectState } from './pokemon';
/** A single action that can be chosen. */
export interface ChosenAction {
    choice: 'move' | 'switch' | 'instaswitch' | 'team' | 'shift' | 'pass';
    pokemon?: Pokemon;
    targetLoc?: number;
    moveid: string;
    move?: ActiveMove;
    target?: Pokemon;
    index?: number;
    side?: Side;
    mega?: boolean | null;
    zmove?: string;
    maxMove?: string;
    priority?: number;
}
/** What the player has chosen to happen. */
export interface Choice {
    cantUndo: boolean;
    error: string;
    actions: ChosenAction[];
    forcedSwitchesLeft: number;
    forcedPassesLeft: number;
    switchIns: Set<number>;
    zMove: boolean;
    mega: boolean;
    ultra: boolean;
    dynamax: boolean;
}
export declare class Side {
    readonly battle: Battle;
    readonly id: SideID;
    readonly n: number;
    name: string;
    avatar: string;
    maxTeamSize: number;
    foe: Side;
    team: PokemonSet[];
    pokemon: Pokemon[];
    active: Pokemon[];
    pokemonLeft: number;
    zMoveUsed: boolean;
    faintedLastTurn: Pokemon | null;
    faintedThisTurn: Pokemon | null;
    /** only used by Gen 1 Counter */
    lastSelectedMove: ID;
    sideConditions: {
        [id: string]: EffectState;
    };
    slotConditions: {
        [id: string]: EffectState;
    }[];
    activeRequest: AnyObject | null;
    choice: Choice;
    lastMove: Move | null;
    constructor(name: string, battle: Battle, sideNum: number, team: PokemonSet[]);
    toJSON(): AnyObject;
    get requestState(): RequestState;
    getChoice(): string;
    toString(): string;
    getRequestData(): {
        id: SideID;
        name: string;
        pokemon: AnyObject[];
    };
    randomActive(): Pokemon | null;
    addSideCondition(status: string | Condition, source?: Pokemon | 'debug' | null, sourceEffect?: Effect | null): boolean;
    getSideCondition(status: string | Effect): Effect | null;
    getSideConditionData(status: string | Effect): AnyObject;
    removeSideCondition(status: string | Effect): boolean;
    addSlotCondition(target: Pokemon | number, status: string | Condition, source?: Pokemon | 'debug' | null, sourceEffect?: Effect | null): any;
    getSlotCondition(target: Pokemon | number, status: string | Effect): import("./dex-formats").Format | import("./dex-species").Species | import("./dex-items").Item | import("./dex-abilities").Ability | import("./dex-moves").ActiveMove | import("./dex-conditions").Condition | null;
    removeSlotCondition(target: Pokemon | number, status: string | Effect): boolean;
    send(...parts: (string | number | Function | AnyObject)[]): void;
    emitRequest(update: AnyObject): void;
    emitChoiceError(message: string, unavailable?: boolean): boolean;
    isChoiceDone(): boolean;
    chooseMove(moveText?: string | number, targetLoc?: number, megaDynaOrZ?: 'mega' | 'zmove' | 'ultra' | 'dynamax' | ''): boolean;
    updateRequestForPokemon(pokemon: Pokemon, update: (req: AnyObject) => boolean): boolean;
    chooseSwitch(slotText?: string): boolean | Side;
    chooseTeam(data?: string): boolean;
    chooseShift(): boolean;
    clearChoice(): void;
    choose(input: string): boolean;
    getChoiceIndex(isPass?: boolean): number;
    choosePass(): boolean | Side;
    /** Automatically finish a choice if not currently complete. */
    autoChoose(): boolean;
    destroy(): void;
}
