import { Condition } from './dex-conditions';
import { DataMove } from './dex-moves';
import { Item } from './dex-items';
import { Ability } from './dex-abilities';
import { Species } from './dex-species';
import { Format, RuleTable } from './dex-formats';
import { AbilityData, AbilityText, ActiveMove, AnyObject, DexTable, Effect, EffectData, FormatData, ID, ItemData, ItemText, LearnsetData, ModdedBattleScriptsData, Move, MoveData, MoveText, Nature, NatureData, PlayerOptions, PokemonSet, SpeciesData, TypeData, TypeInfo } from './exported-global-types';
import * as Data from './dex-data';
import { PRNG, PRNGSeed } from './prng';
declare type DataType = 'Abilities' | 'Formats' | 'FormatsData' | 'Items' | 'Learnsets' | 'Moves' | 'Natures' | 'Pokedex' | 'Scripts' | 'Conditions' | 'TypeChart';
interface DexTableData {
    Abilities: DexTable<AbilityData>;
    Conditions: DexTable<EffectData>;
    Formats: DexTable<FormatData>;
    FormatsData: DexTable<import('./dex-species').ModdedSpeciesFormatsData>;
    Items: DexTable<ItemData>;
    Learnsets: DexTable<LearnsetData>;
    Moves: DexTable<MoveData>;
    Natures: DexTable<NatureData>;
    Pokedex: DexTable<SpeciesData>;
    TypeChart: DexTable<TypeData>;
    Aliases: {
        [id: string]: string;
    };
    Scripts: ModdedBattleScriptsData;
    Species: DexTable<SpeciesData>;
    Types: DexTable<TypeData>;
}
declare const TEXT: {
    Abilities: DexTable<AbilityText>;
    Items: DexTable<ItemText>;
    Moves: DexTable<MoveText>;
    Default: DexTable<AnyObject>;
};
declare type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer V> ? ReadonlyArray<DeepPartial<V>> : DeepPartial<T[P]>;
};
interface TeamGenerator {
    prng: PRNG;
    getTeam(options?: PlayerOptions): PokemonSet[];
    setSeed(prng?: PRNG | PRNGSeed): void;
}
interface TeamGeneratorFactory {
    getTeamGenerator(format: Format | string, seed: PRNG | PRNGSeed | null): TeamGenerator;
}
export declare type ModData = DeepPartial<ModdedDex['data']>;
export declare const toID: typeof Data.toID;
export declare class ModdedDex {
    readonly Data: typeof Data;
    readonly Condition: typeof Condition;
    readonly Ability: typeof Ability;
    readonly Item: typeof Item;
    readonly Move: typeof DataMove;
    readonly Species: typeof Species;
    readonly Format: typeof Format;
    readonly ModdedDex: typeof ModdedDex;
    readonly name = "[ModdedDex]";
    readonly isBase: boolean;
    readonly currentMod: string;
    readonly toID: typeof Data.toID;
    readonly abilityCache: Map<ID, Ability>;
    readonly effectCache: Map<ID, Condition | Ability | Item | import("./dex-moves").ActiveMove | Species | Format | import("./dex-moves").Move>;
    readonly itemCache: Map<ID, Item>;
    readonly learnsetCache: Map<ID, LearnsetData>;
    readonly moveCache: Map<ID, import("./dex-moves").Move>;
    readonly speciesCache: Map<ID, Species>;
    readonly natureCache: Map<ID, Data.Nature>;
    readonly typeCache: Map<string, TypeInfo>;
    gen: number;
    parentMod: string;
    modsLoaded: boolean;
    dataCache: DexTableData | null;
    formatsCache: DexTable<Format> | null;
    deepClone: (obj: any) => any;
    constructor(mod?: string);
    get modid(): ID;
    get data(): DexTableData;
    get formats(): DexTable<Format>;
    get dexes(): {
        [mod: string]: ModdedDex;
    };
    mod(mod: string | undefined, modData?: DeepPartial<ModdedDex['data']>): ModdedDex;
    forGen(gen: number): ModdedDex;
    forFormat(format: Format | string): ModdedDex;
    modData(dataType: DataType, id: string): any;
    effectToString(): string;
    /**
     * Sanitizes a username or Pokemon nickname
     *
     * Returns the passed name, sanitized for safe use as a name in the PS
     * protocol.
     *
     * Such a string must uphold these guarantees:
     * - must not contain any ASCII whitespace character other than a space
     * - must not start or end with a space character
     * - must not contain any of: | , [ ]
     * - must not be the empty string
     * - must not contain Unicode RTL control characters
     *
     * If no such string can be found, returns the empty string. Calling
     * functions are expected to check for that condition and deal with it
     * accordingly.
     *
     * getName also enforces that there are not multiple consecutive space
     * characters in the name, although this is not strictly necessary for
     * safety.
     */
    getName(name: any): string;
    /**
     * Returns false if the target is immune; true otherwise.
     * Also checks immunity to some statuses.
     */
    getImmunity(source: {
        type: string;
    } | string, target: {
        getTypes: () => string[];
    } | {
        types: string[];
    } | string[] | string): boolean;
    getEffectiveness(source: {
        type: string;
    } | string, target: {
        getTypes: () => string[];
    } | {
        types: string[];
    } | string[] | string): number;
    getSpecies(name?: string | Species): Species;
    getLearnsetData(id: ID): LearnsetData;
    getLearnset(name?: string): Promise<Data.Learnset>;
    getDescs(table: keyof typeof TEXT, id: ID, dataEntry: AnyObject): {
        desc: any;
        shortDesc: any;
    } | null;
    getMove(name?: string | Move): Move;
    /**
     * Ensure we're working on a copy of a move (and make a copy if we aren't)
     *
     * Remember: "ensure" - by default, it won't make a copy of a copy:
     *     moveCopy === Dex.getActiveMove(moveCopy)
     *
     * If you really want to, use:
     *     moveCopyCopy = Dex.getActiveMove(moveCopy.id)
     */
    getActiveMove(move: Move | string): ActiveMove;
    /**
     * While this function can technically return any kind of effect at
     * all, that's not a feature TypeScript needs to know about.
     */
    getEffect(name?: string | Effect | null): Condition;
    getEffectByID(id: ID, effect?: Effect | Move): Condition;
    /**
     * Returns a sanitized format ID if valid, or throws if invalid.
     */
    validateFormat(name: string): string;
    getFormat(name?: string | Format, isTrusted?: boolean): Format;
    getItem(name?: string | Item): Item;
    getAbility(name?: string | Ability): Ability;
    hasAbility(species: Species, ability: string): boolean;
    getType(name?: string | TypeInfo): TypeInfo;
    getNature(name: string | Nature): Nature;
    getHiddenPower(ivs: AnyObject): {
        type: string;
        power: number;
    };
    getRuleTable(format: Format, depth?: number, repeals?: Map<string, number>): RuleTable;
    validateRule(rule: string, format?: Format | null): string | (string | number | string[])[];
    validateBanRule(rule: string): string;
    shuffle<T>(arr: T[]): T[];
    /** Forces num to be an integer (between min and max). */
    clampIntRange(num: any, min?: number, max?: number): number;
    /**
     * Truncate a number into an unsigned 32-bit integer, for
     * compatibility with the cartridge games' math systems.
     */
    trunc(num: number, bits?: number): number;
    generateTeam(format: Format | string, options?: PlayerOptions | null): PokemonSet[];
    getTeamGenerator(format: Format | string, seed?: PRNG | PRNGSeed | null): any;
    setTeamGeneratorFactory(factory: TeamGeneratorFactory): this;
    packTeam(team: PokemonSet[] | null): string;
    fastUnpackTeam(buf: string): PokemonSet[] | null;
    loadDataFile(mod: string, dataType: DataType | 'Aliases', modData?: DeepPartial<ModdedDex['data']>): AnyObject;
    includeMods(): ModdedDex;
    includeModData(): ModdedDex;
    includeData(): ModdedDex;
    loadData(modData?: DeepPartial<ModdedDex['data']>): DexTableData;
    includeFormats(): ModdedDex;
}
export declare const Dex: ModdedDex;
export declare namespace Dex {
    type Species = import('./dex-species').Species;
    type Item = import('./dex-items').Item;
    type Move = import('./dex-moves').Move;
    type Ability = import('./dex-abilities').Ability;
    type HitEffect = import('./dex-moves').HitEffect;
    type SecondaryEffect = import('./dex-moves').SecondaryEffect;
    type RuleTable = import('./dex-formats').RuleTable;
}
export {};
