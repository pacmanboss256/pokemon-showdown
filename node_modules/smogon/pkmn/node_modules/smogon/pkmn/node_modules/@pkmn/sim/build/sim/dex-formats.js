"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeFormatLists = exports.Format = exports.RuleTable = void 0;
const utils_1 = require("../lib/utils");
const dex_data_1 = require("./dex-data");
/**
 * A RuleTable keeps track of the rules that a format has. The key can be:
 * - '[ruleid]' the ID of a rule in effect
 * - '-[thing]' or '-[category]:[thing]' ban a thing
 * - '+[thing]' or '+[category]:[thing]' allow a thing (override a ban)
 * [category] is one of: item, move, ability, species, basespecies
 *
 * The value is the name of the parent rule (blank for the active format).
 */
class RuleTable extends Map {
    constructor() {
        super();
        this.complexBans = [];
        this.complexTeamBans = [];
        this.checkLearnset = null;
        this.timer = null;
        this.minSourceGen = null;
    }
    isBanned(thing) {
        if (this.has(`+${thing}`))
            return false;
        return this.has(`-${thing}`);
    }
    isBannedSpecies(species) {
        if (this.has(`+pokemon:${species.id}`))
            return false;
        if (this.has(`-pokemon:${species.id}`))
            return true;
        if (this.has(`+basepokemon:${dex_data_1.toID(species.baseSpecies)}`))
            return false;
        if (this.has(`-basepokemon:${dex_data_1.toID(species.baseSpecies)}`))
            return true;
        const tier = species.tier === '(PU)' ? 'ZU' : species.tier === '(NU)' ? 'PU' : species.tier;
        if (this.has(`+pokemontag:${dex_data_1.toID(tier)}`))
            return false;
        if (this.has(`-pokemontag:${dex_data_1.toID(tier)}`))
            return true;
        const doublesTier = species.doublesTier === '(DUU)' ? 'DNU' : species.doublesTier;
        if (this.has(`+pokemontag:${dex_data_1.toID(doublesTier)}`))
            return false;
        if (this.has(`-pokemontag:${dex_data_1.toID(doublesTier)}`))
            return true;
        return this.has(`-pokemontag:allpokemon`);
    }
    isRestricted(thing) {
        if (this.has(`+${thing}`))
            return false;
        return this.has(`*${thing}`);
    }
    isRestrictedSpecies(species) {
        if (this.has(`+pokemon:${species.id}`))
            return false;
        if (this.has(`*pokemon:${species.id}`))
            return true;
        if (this.has(`+basepokemon:${dex_data_1.toID(species.baseSpecies)}`))
            return false;
        if (this.has(`*basepokemon:${dex_data_1.toID(species.baseSpecies)}`))
            return true;
        const tier = species.tier === '(PU)' ? 'ZU' : species.tier === '(NU)' ? 'PU' : species.tier;
        if (this.has(`+pokemontag:${dex_data_1.toID(tier)}`))
            return false;
        if (this.has(`*pokemontag:${dex_data_1.toID(tier)}`))
            return true;
        const doublesTier = species.doublesTier === '(DUU)' ? 'DNU' : species.doublesTier;
        if (this.has(`+pokemontag:${dex_data_1.toID(doublesTier)}`))
            return false;
        if (this.has(`*pokemontag:${dex_data_1.toID(doublesTier)}`))
            return true;
        return this.has(`*pokemontag:allpokemon`);
    }
    check(thing, setHas = null) {
        if (this.has(`+${thing}`))
            return '';
        if (setHas)
            setHas[thing] = true;
        return this.getReason(`-${thing}`);
    }
    getReason(key) {
        const source = this.get(key);
        if (source === undefined)
            return null;
        if (key === '-nonexistent' || key.startsWith('obtainable')) {
            return 'not obtainable';
        }
        return source ? `banned by ${source}` : `banned`;
    }
    getComplexBanIndex(complexBans, rule) {
        const ruleId = dex_data_1.toID(rule);
        let complexBanIndex = -1;
        for (let i = 0; i < complexBans.length; i++) {
            if (dex_data_1.toID(complexBans[i][0]) === ruleId) {
                complexBanIndex = i;
                break;
            }
        }
        return complexBanIndex;
    }
    addComplexBan(rule, source, limit, bans) {
        const complexBanIndex = this.getComplexBanIndex(this.complexBans, rule);
        if (complexBanIndex !== -1) {
            if (this.complexBans[complexBanIndex][2] === Infinity)
                return;
            this.complexBans[complexBanIndex] = [rule, source, limit, bans];
        }
        else {
            this.complexBans.push([rule, source, limit, bans]);
        }
    }
    addComplexTeamBan(rule, source, limit, bans) {
        const complexBanTeamIndex = this.getComplexBanIndex(this.complexTeamBans, rule);
        if (complexBanTeamIndex !== -1) {
            if (this.complexTeamBans[complexBanTeamIndex][2] === Infinity)
                return;
            this.complexTeamBans[complexBanTeamIndex] = [rule, source, limit, bans];
        }
        else {
            this.complexTeamBans.push([rule, source, limit, bans]);
        }
    }
}
exports.RuleTable = RuleTable;
class Format extends dex_data_1.BasicEffect {
    constructor(data, ...moreData) {
        super(data, ...moreData);
        data = this;
        this.mod = utils_1.Utils.getString(data.mod) || 'gen8';
        this.effectType = utils_1.Utils.getString(data.effectType) || 'Format';
        this.debug = !!data.debug;
        this.rated = (typeof data.rated === 'string' ? data.rated : data.rated !== false);
        this.gameType = data.gameType || 'singles';
        this.ruleset = data.ruleset || [];
        this.baseRuleset = data.baseRuleset || [];
        this.banlist = data.banlist || [];
        this.restricted = data.restricted || [];
        this.unbanlist = data.unbanlist || [];
        this.customRules = data.customRules || null;
        this.ruleTable = null;
        this.teamLength = data.teamLength || undefined;
        this.onBegin = data.onBegin || undefined;
        this.minSourceGen = data.minSourceGen || undefined;
        this.maxLevel = data.maxLevel || 100;
        this.defaultLevel = data.defaultLevel || this.maxLevel;
        this.forcedLevel = data.forcedLevel || undefined;
        this.maxForcedLevel = data.maxForcedLevel || undefined;
        this.noLog = !!data.noLog;
    }
}
exports.Format = Format;
/** merges format lists from config/formats and config/custom-formats */
function mergeFormatLists(main, custom) {
    // result that is return and makes the actual list for formats.
    const result = [];
    // used as a intermediary to build the final list.
    const build = [];
    // used to track current section to keep formats under their sections.
    let current = { section: "", formats: [] };
    // populates the original sections and formats easily
    // there should be no repeat sections at this point.
    for (const element of main) {
        if (element.section) {
            current = { section: element.section, column: element.column, formats: [] };
            build.push(current);
        }
        else if (element.name) {
            current.formats.push(element);
        }
    }
    // merges the second list the hard way. Accounts for repeats.
    if (custom !== undefined) {
        for (const element of custom) {
            // finds the section and makes it if it doesn't exist.
            if (element.section) {
                current = build.find(e => e.section === element.section);
                // if it's new it makes a new entry.
                if (current === undefined) {
                    current = { section: element.section, column: element.column, formats: [] };
                    build.push(current);
                }
            }
            else if (element.name) { // otherwise, adds the element to its section.
                current.formats.push(element);
            }
        }
    }
    // builds the final result.
    for (const element of build) {
        // adds the section to the list.
        result.push({ section: element.section, column: element.column }, ...element.formats);
    }
    return result;
}
exports.mergeFormatLists = mergeFormatLists;
//# sourceMappingURL=dex-formats.js.map