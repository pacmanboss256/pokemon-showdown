import { AbilityName, Condition, Data, Dex, EggGroup, EvoType, FormeName, GenderName, GenerationNum, ID, ItemName, MoveCategory, MoveName, Nature, Nonstandard, Species as DexSpecies, SpeciesAbility, SpeciesName, StatName, StatsTable, Tier, Type as DexType, TypeName } from '@pkmn/dex-types';
declare const DEFAULT_EXISTS: (d: Data) => boolean;
declare type ExistsFn = typeof DEFAULT_EXISTS;
export declare function toID(text: any): ID;
export declare class Generations {
    private readonly cache;
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists?: (d: Data) => boolean);
    get(gen: GenerationNum): Generation;
    [Symbol.iterator](): Generator<Generation, void, unknown>;
}
export declare class Generation {
    readonly abilities: Abilities;
    readonly items: Items;
    readonly moves: Moves;
    readonly species: Species;
    readonly types: Types;
    readonly natures: Natures;
    readonly learnsets: Learnsets;
    readonly effects: Effects;
    readonly stats: Stats;
    readonly dex: Dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get num(): GenerationNum;
}
export declare class Abilities {
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): import("@pkmn/dex-types").Ability | undefined;
    [Symbol.iterator](): Generator<import("@pkmn/dex-types").Ability, void, unknown>;
}
export declare class Items {
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): import("@pkmn/dex-types").Item | undefined;
    [Symbol.iterator](): Generator<import("@pkmn/dex-types").Item, void, unknown>;
}
export declare class Moves {
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): import("@pkmn/dex-types").Move | undefined;
    [Symbol.iterator](): Generator<import("@pkmn/dex-types").Move, void, unknown>;
}
export declare class Species {
    private readonly cache;
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): Specie | undefined;
    [Symbol.iterator](): Generator<Specie, void, unknown>;
}
export declare class Specie implements DexSpecies {
    readonly id: ID;
    readonly name: SpeciesName;
    readonly fullname: string;
    readonly exists: boolean;
    readonly num: number;
    readonly gen: GenerationNum;
    readonly shortDesc: string;
    readonly desc: string;
    readonly isNonstandard: Nonstandard | null;
    readonly duration?: number;
    readonly effectType: 'Pokemon';
    readonly kind: 'Species';
    readonly baseStats: StatsTable;
    readonly baseSpecies: SpeciesName;
    readonly baseForme: FormeName | '';
    readonly forme: FormeName | '';
    readonly abilities: SpeciesAbility<AbilityName | ''>;
    readonly types: [TypeName] | [TypeName, TypeName];
    readonly prevo?: SpeciesName | '';
    readonly evos?: SpeciesName[];
    readonly nfe: boolean;
    readonly eggGroups: EggGroup[];
    readonly weightkg: number;
    readonly weighthg: number;
    readonly heightm: number;
    readonly unreleasedHidden: boolean | 'Past';
    readonly maleOnlyHidden: boolean;
    readonly inheritsFrom: ID;
    readonly tier: Tier.Singles | Tier.Other;
    readonly doublesTier: Tier.Doubles;
    readonly evoMove?: MoveName;
    readonly cosmeticFormes?: SpeciesName[];
    readonly otherFormes?: SpeciesName[];
    readonly formeOrder?: SpeciesName[];
    readonly formes?: SpeciesName[];
    readonly genderRatio: {
        M: number;
        F: number;
    };
    readonly isMega?: boolean;
    readonly isPrimal?: boolean;
    readonly battleOnly?: SpeciesName | SpeciesName[];
    readonly isGigantamax?: MoveName;
    readonly requiredAbility?: AbilityName;
    readonly requiredItem?: ItemName;
    readonly requiredItems?: ItemName[];
    readonly requiredMove?: MoveName;
    readonly gender?: GenderName;
    readonly maxHP?: number;
    readonly evoLevel?: number;
    readonly evoCondition?: string;
    readonly evoItem?: string;
    readonly evoType?: EvoType;
    readonly condition?: Partial<Condition>;
    readonly canHatch: boolean;
    private readonly dex;
    private static readonly EXCLUDE;
    constructor(dex: Dex, exists: ExistsFn, species: DexSpecies);
    hasAbility(ability: string): boolean;
    get formeNum(): number;
}
export declare class Effects {
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): import("@pkmn/dex-types").Ability | import("@pkmn/dex-types").Item | import("@pkmn/dex-types").Move | Condition | undefined;
}
export declare class Natures {
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): Nature | undefined;
    [Symbol.iterator](): Generator<Nature, void, unknown>;
}
declare type TypeTarget = {
    getTypes: () => TypeName[];
} | {
    types: TypeName[];
} | TypeName[] | TypeName;
export declare class Types {
    private readonly cache;
    private readonly unknown;
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): Type | undefined;
    [Symbol.iterator](): Generator<Type, void, unknown>;
    getHiddenPower(ivs: StatsTable): {
        type: TypeName;
        power: number;
    };
    canDamage(source: {
        type: TypeName;
    } | TypeName, target: TypeTarget): boolean;
    totalEffectiveness(source: {
        type: TypeName;
    } | TypeName, target: TypeTarget): number;
}
export declare type TypeEffectiveness = 0 | 0.5 | 1 | 2;
export declare class Type {
    readonly id: ID;
    readonly name: TypeName;
    readonly effectType: 'Type';
    readonly kind: 'Type';
    readonly exists: boolean;
    readonly gen: GenerationNum;
    readonly effectiveness: {
        [t in TypeName]: TypeEffectiveness;
    };
    readonly HPivs: Partial<StatsTable>;
    readonly HPdvs: Partial<StatsTable>;
    readonly category?: Exclude<MoveCategory, 'Status'>;
    private readonly types;
    constructor(type: DexType, dex: Dex, types: Types);
    canDamage(target: TypeTarget): boolean;
    totalEffectiveness(target: TypeTarget): number;
}
export declare class Learnsets {
    private readonly dex;
    private readonly exists;
    constructor(dex: Dex, exists: ExistsFn);
    get(name: string): Promise<import("@pkmn/dex-types").Learnset | undefined>;
    [Symbol.iterator](): AsyncGenerator<import("@pkmn/dex-types").Learnset, void, unknown>;
}
export declare class Stats {
    private readonly dex;
    constructor(dex: Dex);
    calc(stat: StatName, base: number, iv?: number, ev?: number, level?: number, nature?: Nature): number;
    get(s: string): StatName | undefined;
    display(str: string, full?: boolean): string;
    fill<T>(stats: Partial<StatsTable<T>>, val: T): StatsTable<T>;
    getHPDV(ivs: Partial<StatsTable>): number;
    [Symbol.iterator](): IterableIterator<StatName>;
    toDV(iv: number): number;
    toIV(dv: number): number;
}
export { ID, As, Weather, FieldCondition, SideCondition, GenerationNum, GenderName, StatName, StatsTable, BoostName, BoostsTable, MoveCategory, MoveTarget, Nonstandard, EvoType, EggGroup, SideID, Player, GameType, HPColor, StatusName, NatureName, TypeName, HPTypeName, Tier, PokemonSet, AbilityName, ItemName, MoveName, SpeciesName, FormeName, EffectType, Effect, DataKind, Data, EffectData, HitEffect, SecondaryEffect, ConditionData, AbilityData, ItemData, MoveData, SpeciesData, MoveSource, EventInfoData, LearnsetData, TypeData, NatureData, BasicEffect, Condition, Ability, Item, Move, EventInfo, Learnset, Nature, GenID, Dex, } from '@pkmn/dex-types';
